PROJECT SPEC (FOR CODEX)
Project: EURUSD Swing Bias Bot (Python) + MT5 EA (MQL5)
Objective

Build a two-part automated system:

Python Bias Engine runs once per day (Asia/Bangkok morning), computes a repeatable bias for EURUSD and writes a JSON file into MT5 MQL5/Files.

MQL5 EA runs in MT5, evaluates trades only on H4 candle close, reads the bias JSON, and places/manage trades according to strict rules:

EURUSD only

H4 entry timeframe

One position at a time

No chase entries

SL/TP rule-based

Scale-out: TP1 closes 50% at 1R then SL->BE, TP2 closes remaining at 2R

Append trade logs to CSV (for analysis & tagging in Python)

The system must be deterministic and debuggable (file-based bridge).

Directory / Files
Python project

python/

main.py (entrypoint; writes bias file)

bias_engine.py (features + scoring + state)

data_fred.py (US2Y fetch)

data_mt5.py (EURUSD OHLC fetch via MetaTrader5 package OR stub)

history_store.py (store last N days of bias strength for trend calc)

trade_analyzer.py (reads trade_log.csv, computes daily/weekly fuse, optional tagging)

config.yaml (paths, thresholds)

MT5 side

EA file(s): MQL5/Experts/EURUSD_SwingEA.mq5

Read JSON from: MQL5/Files/bias_eurusd.json

Append logs to: MQL5/Files/trade_log.csv

1. Shared Contract: Bias JSON (Python -> EA)

File: bias_eurusd.json (UTF-8)

JSON Schema (required fields)
{
"symbol": "EURUSD",
"asof_utc": "YYYY-MM-DDTHH:MM:SSZ",

"direction": "LONG|SHORT|NEUTRAL",
"strength": 0,
"label": "WEAK|MED|STRONG",
"bias_trend": "STRENGTHENING|WEAKENING|STABLE",
"early_reversal_warning": false,

"event_risk": "LOW|HIGH",
"ttl_days": 3,

"trade_permission": "YES|NO",
"risk_per_trade_pct": 0.0,

"notes": "string"
}

Freshness requirement

EA must reject bias file if asof_utc is older than 30 hours.

Risk mapping rules (Python must enforce)

If strength in 7..10 => label="STRONG", risk_per_trade_pct=1.0

If strength in 4..6 => label="MED", risk_per_trade_pct=0.5

If strength in 0..3 => label="WEAK", risk_per_trade_pct=0.0
Overrides:

If event_risk=="HIGH" OR early_reversal_warning==true => risk_per_trade_pct=0.0 and trade_permission="NO"

Trade permission rule (Python must enforce)

trade_permission="YES" only if:

direction != NEUTRAL

strength >= 6

bias_trend != WEAKENING

early_reversal_warning == false

event_risk == LOW
Else NO.

2. Python Bias Engine Spec
   Runtime

Run once per day (recommended 07:30–09:00 Bangkok time).

Output JSON to MT5 MQL5/Files.

Inputs (v0 required)

US 2Y yield time series (FRED DGS2)

EURUSD OHLC series:

D1 (for trend alignment)

H4 (optional in Python; EA uses H4 anyway)

Event risk flag:

v0: default LOW

v1: integrate calendar API (not required now)

Feature calculations

From US2Y:

dgs2_delta_5d = dgs2[t] - dgs2[t-5]

dgs2_delta_20d = dgs2[t] - dgs2[t-20]

dgs2_zscore_5d = z-score of dgs2_delta_5d using rolling window (e.g., 60 or 252)

From EURUSD D1:

Simple trend alignment:

compute MA20 and its slope: ma20[t] - ma20[t-5]

if slope > 0 => bullish regime, slope < 0 => bearish regime

Direction rules (v0)

If dgs2_delta_20d < 0 AND dgs2_zscore_5d <= -1.0 => direction="LONG"

If dgs2_delta_20d > 0 AND dgs2_zscore_5d >= +1.0 => direction="SHORT"

Else direction="NEUTRAL"

Strength score (0–10)

Components:

US2Y shock score (0–4) from abs(dgs2_zscore_5d):

<0.5 => 0

0.5–1.0 => 1

1.0–1.5 => 2

1.5–2.0 => 3

=2.0 => 4

D1 alignment score (0–3):

If direction LONG and D1 bullish => 3

If direction SHORT and D1 bearish => 3

If NEUTRAL => 0

If mixed/flat => 1

If opposite => 0

Confirm score (0–2): v0 set to 0 unless DXY added later

Event penalty (0 to -3): v0 set to 0 unless event_risk HIGH

strength = clamp(us2y + align + confirm + penalty, 0, 10)

Bias trend + early reversal

Maintain a local history file bias_history.csv with columns:
date_utc, direction, strength
Compute:

avg3 = mean(last_3_strength)

delta3 = strength_today - avg3
Bias trend:

delta3 >= +1 => STRENGTHENING

delta3 <= -1 => WEAKENING

else STABLE

Early reversal warning = true if any:

strength dropped by >=3 within last 2 days (e.g., 8->5)

OR direction flipped within last 2 days

TTL rule

v0 constant: ttl_days = 3 (since swing 3–5 days)

v1: set TTL to next high-impact event date diff.

Output

Write JSON atomically:

write to temp file then rename to bias_eurusd.json to avoid partial reads.

Optional (recommended): Safety fuse via trade_log.csv

Python may read MT5 trade_log.csv and enforce:

daily sum(pnl_r) <= -2 => set trade_permission="NO", risk_per_trade_pct=0.0

weekly sum(pnl_r) <= -4 => same until next week
This is a “fuse” not market prediction. Process gating should still be driven by ENTRY_BAD frequency (i.e., bad-entry rate), with fuse acting only as a safety cutoff.

3. MQL5 EA Spec (EURUSD_SwingEA.mq5)
   Core constraints

Trades only symbol EURUSD.

Works on H4 chart; evaluate only at H4 candle close. Entry signals must use the last closed H4 candle only (MQL5 index 1: Close[1], High[1], Low[1]); index 0 (current forming candle) must NOT be used for entry decisions.

One open position at a time (for EURUSD, magic number). If any EURUSD position by this magic is open, do not open new ones; only manage TP1/BE/TP2. Partial closes may create multiple deals/log rows, but still count as a single position while open.

Reads bias_eurusd.json at each H4 close.

If bias is invalid => no new trade.
Bias alone must never trigger an entry. EA opens a trade only if: bias is valid AND Setup A/B is detected AND anti-chase passes.

New H4 bar detection

Implement function to detect new H4 bar (compare last known bar time).

Swing definition (Fractal 2–2 on H4)

Swing High at index i:

High[i] > High[i-1], High[i-2], High[i+1], High[i+2]
Swing Low at index i:

Low[i] < Low[i-1], Low[i-2], Low[i+1], Low[i+2]
Use the most recent confirmed swing high/low.

Fallback if no swing found:

Highest high / Lowest low in last N=10 H4 bars.

ATR

Compute ATR(H4,14).

Anti-chase rule

Set chase_risk=true if:

distance from breakout level to current price > 1.2 \* ATR
OR

last H4 candle range > 1.5 \* ATR
If chase_risk true => do not open a new trade.

Setups (A/B only)

Setup A: Break & Retest (use last closed H4 candle, index 1)

Identify breakout level = previous swing high (for LONG) or swing low (for SHORT)

Break confirm:

LONG: Close[1] > level + 0.1\*ATR

SHORT: Close[1] < level - 0.1\*ATR

Retest:

price returns near level within tolerance using last closed candle (e.g., abs(Low[1]-level) < 0.2\*ATR for LONG)

Confirmation:

latest closed H4 candle (index 1) closes in direction (bullish for LONG / bearish for SHORT)

Setup B: Pullback to Zone (use last closed H4 candle, index 1)
Zone from latest swing:

LONG zone = [swing_low, swing_low + 0.5*ATR]

SHORT zone = [swing_high - 0.5*ATR, swing_high]
Entry trigger:

price enters zone AND latest closed candle (index 1) closes back in bias direction

SL rule (structure-based, not fixed)

SL must be structure-based using Fractal 2–2 swings (fallback to highest/lowest last 10 H4 bars), with a 0.2×ATR buffer.

LONG: SL = swing_low - 0.2\*ATR

SHORT: SL = swing_high + 0.2\*ATR

TP + scale-out (rule-based in R units, not fixed)

Let R = abs(entry - SL) in price (derived from entry and structure-based SL).

TP1 = entry + R (LONG) or entry - R (SHORT) [1R]

TP2 = entry + 2R or entry - 2R [2R]
On TP1 hit:

close 50% volume (respect min lot step)

move SL to break-even (entry)
On TP2 hit:

close remaining

Position sizing

From JSON:

risk_per_trade_pct in {0.0, 0.5, 1.0}
Compute:

R_money = AccountEquity() \* (risk_per_trade_pct/100.0)

SL_points = abs(entry - SL) / \_Point

Use tick_value and tick_size to compute money per point per lot for symbol:

money_per_point_per_lot = tick_value / tick_size \* \_Point (validate carefully)

lots = R_money / (SL_points \* money_per_point_per_lot)
Normalize lots by:

min lot, max lot, lot step

Logging to CSV

Append row on each close event (including partial closes).
File: trade_log.csv (create with header if missing)
Required columns (write these exact names):
run_id,ticket,symbol,side,entry_time_utc,exit_time_utc,entry_price,sl_price,tp1_price,tp2_price,exit_price,equity_at_entry,risk_per_trade_pct,r_money,r_pips,lots,pnl_money,pnl_r,spread_points_entry,slippage_points_entry,rule_ok_setup,rule_ok_chase,rule_ok_rr,rule_ok_sl,bias_asof_utc,bias_direction,bias_strength,bias_label,bias_trend,early_reversal_warning,event_risk,ttl_days,root_cause_tag,notes

For partial close TP1:

log a row for the partial deal (lots = closed_lots for TP1, pnl_r = realized_pnl_money / R_money)
Final close:

log another row for the remaining volume

Safety behavior

If JSON missing/invalid/outdated:

do not open new trades

still manage existing position (TP1/TP2) normally

4. Deliverables / TODO list (Codex should implement)
   Python (v0)

Fetch US2Y DGS2 from FRED (with API key from env or config)

Fetch EURUSD OHLC D1 (via MetaTrader5 package or stub)

Compute direction, strength, label, bias_trend, warning

Enforce trade_permission + risk mapping

Write bias_eurusd.json atomically to MT5 Files folder

Maintain bias_history.csv for trend calc

MQL5 EA (v0)

Read bias_eurusd.json (simple JSON parser or manual string extraction)

New H4 bar detection

Swing fractal 2–2 detection + fallback

ATR(14)

Setup A/B detection

Anti-chase filter

Lot sizing

Order send + TP1 partial close + SL->BE + TP2 close

Append trade_log.csv with header if missing

Optional (v1)

Python reads trade_log.csv to compute daily/weekly fuse and update trade_permission

Event calendar integration to set event_risk/ttl_days

5. Non-functional requirements

Deterministic (same inputs -> same outputs)

Fail-safe (missing data => no new trade)

Logging is mandatory and human-readable

Keep code modular and documented
